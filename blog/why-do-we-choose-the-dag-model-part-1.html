<!doctype html>
<html lang="en-US" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.0">
<title data-rh="true">Unveiling KubeBlocks Technology (Part 1) -- Why Do We Choose the DAG Model? | KubeBlocks</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://kubeblocks.io/blog/why-do-we-choose-the-dag-model-part-1"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Unveiling KubeBlocks Technology (Part 1) -- Why Do We Choose the DAG Model? | KubeBlocks"><meta data-rh="true" name="description" content="This article discusses the problems with the current implementation of Kubernetes&#x27; Cluster Controller and introduces KubeBlocks, a new model that uses a Directed Acyclic Graph (DAG) to express a cluster."><meta data-rh="true" property="og:description" content="This article discusses the problems with the current implementation of Kubernetes&#x27; Cluster Controller and introduces KubeBlocks, a new model that uses a Directed Acyclic Graph (DAG) to express a cluster."><meta data-rh="true" property="og:image" content="https://kubeblocks.io/img/blog-banner.png"><meta data-rh="true" name="twitter:image" content="https://kubeblocks.io/img/blog-banner.png"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-05-10T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/free6om"><meta data-rh="true" property="article:tag" content="DAG Model"><link data-rh="true" rel="icon" href="/img/favicon2.png"><link data-rh="true" rel="canonical" href="https://kubeblocks.io/blog/why-do-we-choose-the-dag-model-part-1"><link data-rh="true" rel="alternate" href="https://kubeblocks.io/blog/why-do-we-choose-the-dag-model-part-1" hreflang="en-US"><link data-rh="true" rel="alternate" href="https://kubeblocks.io/blog/why-do-we-choose-the-dag-model-part-1" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://SES9RBYTIC-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="KubeBlocks RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="KubeBlocks Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1P80WT42PB"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1P80WT42PB",{anonymize_ip:!0})</script>


<link rel="search" type="application/opensearchdescription+xml" title="KubeBlocks" href="/opensearch.xml">


<meta name="version" content="1683777715926"><link rel="stylesheet" href="/assets/css/styles.7693a9de.css">
<link rel="preload" href="/assets/js/runtime~main.f6a80365.js" as="script">
<link rel="preload" href="/assets/js/main.5ffecbf3.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.png" alt="Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.png" alt="Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div></a><a class="navbar__item navbar__link" href="/docs/release-0.4/user_docs/introduction">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blogs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Webinar</a></div><div class="navbar__items navbar__items--right"><div class="searchBox_ZlJk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><main class="col col--10" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><meta itemprop="image" content="https://kubeblocks.io/img/blog-banner.png"><header><h1 class="title_f1Hy" itemprop="headline">Unveiling KubeBlocks Technology (Part 1) -- Why Do We Choose the DAG Model?</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-05-10T00:00:00.000Z" itemprop="datePublished">May 10, 2023</time> · <!-- -->11 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/free6om" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://avatars.githubusercontent.com/u/28781141?v=4" alt="free6om"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/free6om" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">free6om</span></a></div></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithStickyNavbar_LWe7" id="background">Background<a href="#background" class="hash-link" aria-label="Direct link to Background" title="Direct link to Background">​</a></h2><p>In the current implementation of Kubernetes, the Cluster Controller is responsible for most of the Reconcile logic, which is the core control logic used to maintain the consistency of the Kubernetes system. However, the Cluster Controller is too bulky and complex, and lacks clear abstraction levels and separation of concerns in its design. This makes it difficult to modify and add new logic, which can increase the difficulty of maintenance and modification during continuous iterations. In other words, modifying a small logical point may affect the entire system, causing unnecessary risks.</p><p>We analyzed the main logic of the current code. In this article, we provide a more structured plan for refactoring, including detailed explanations of several key issues in the plan.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="current-model---prepare-checkedcreate-pattern">Current Model - <code>prepare-checkedCreate</code> pattern<a href="#current-model---prepare-checkedcreate-pattern" class="hash-link" aria-label="Direct link to current-model---prepare-checkedcreate-pattern" title="Direct link to current-model---prepare-checkedcreate-pattern">​</a></h2><p>In the Cluster Controller, the operation of the cluster object is mainly in the <a href="https://github.com/apecloud/kubeblocks/blob/main/controllers/apps/lifecycle_utils.go#L77" target="_blank" rel="noopener noreferrer"><code>reconcileClusterWorkloads</code></a> function, which uses the <code>prepare-checkedCreate</code> pattern: First, prepare all the required K8s objects according to <code>cluster.spec</code> (prepare phase); then try to create these objects. When the API Server returns an object already exists error (<code>metav1.StatusReasonAlreadyExists</code>), call the update function again to update these objects (checkedCreate phase).</p><p>This pattern has two problems:</p><ul><li>The first problem is that when a particular object has special business logic, it needs to be patched. For example, in KubeBlocks, once the configuration file is generated, it cannot be modified. Therefore, when updating the cluster, the ConfigMap of the configuration file needs to be filtered out in the prepare phase. Similarly, if the credential corresponds to the Secret needs to be created before other objects, the generation logic of the Secret needs to be placed before other objects. If the order is not noticed in subsequent iterations, it can cause unexpected problems.</li><li>The second problem is that if a component is deleted during a cluster update, the corresponding object will become an orphan object drifting in the Kubernetes cluster.</li></ul><p>In addition, this pattern has other potential problems caused by functional coupling that can lead to code conflicts. So refactoring starts here.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-kubeblocks-model">The KubeBlocks Model<a href="#the-kubeblocks-model" class="hash-link" aria-label="Direct link to The KubeBlocks Model" title="Direct link to The KubeBlocks Model">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="why-do-we-use-dag">Why do we use DAG?<a href="#why-do-we-use-dag" class="hash-link" aria-label="Direct link to Why do we use DAG?" title="Direct link to Why do we use DAG?">​</a></h3><p><a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank" rel="noopener noreferrer">DAG（Directed acyclic graph)</a> is a data structure that has been extensively studied, and we can leverage a lot of existing knowledge and experience to make our construction process easier.</p><p>A <code>cluster</code> contains multiple K8s objects such as CD, CV, StatefulSet, Deployment, ConfigMap, Secret, Service, PVC, and KubeBlocks abstract CRDs, and these objects have dependencies (such as the credentials Secret needs to be created before other objects). Therefore, we can use DAG to express a <code>cluster</code>.</p><p>With such an abstract structure, we can transform many requirements into an operation on the DAG. For example, in the face of the requirement that <em>the configuration file ConfigMap cannot be updated</em>, we can define an operation that will traverse the DAG using the BFS (breadth-first search) algorithm and then delete or set the ConfigMap in it to immutable. In response to the requirement that <em>the credentials Secret must be created before other objects</em>, we can define another operation that adds all other objects to the dependency relationship of the Secret to ensure that the requirement is met.</p><p>We can abstract the &quot;operation&quot; mentioned above, which leads us to the second data structure: Transformer. The role of the Transformer is to &quot;transform&quot; a DAG into another DAG.</p><p>When we add new business logic later, we can write a new Transformer. In this way, we have established a continuous and iterative model, and the code coupling degree has also been reduced.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-plan">The <em>Plan</em><a href="#the-plan" class="hash-link" aria-label="Direct link to the-plan" title="Direct link to the-plan">​</a></h3><font color="#c5161b"> After applying a series of Transformers, we obtain a final Directed Acyclic Graph (DAG). What should we do next? </font><p>If each Node in this DAG has a K8s object and its corresponding operation (Create/Update/Delete), it would be very friendly, wouldn&#x27;t it? If each edge represents the order in which they are executed, would it be better? If I just write a bunch of Transformers and apply them, and the final execution does not require my efforts, would it be close to perfection?</p><p>We abstract the last step of &quot;execution&quot;, giving us the last data structure: <em>Plan</em>. The Plan is an execution plan that traverses the final DAG processed earlier and performs some actions. After the execution is completed, the cluster object reaches the declared state (i.e. the completion of this reconcile).</p><p>The above is the KubeBlocks&#x27; model, and you can check the <a href="https://github.com/apecloud/kubeblocks/pull/1571" target="_blank" rel="noopener noreferrer">code frame</a> for <a href="https://github.com/apecloud/kubeblocks/pull/1571/files#diff-156cb301a9e77d9539ae0021bdc6beadcbdcfdf3e75b72240fa3b75d7cd7c7faR40" target="_blank" rel="noopener noreferrer">detailed information</a>.</p><p>Can the KubeBlocks model solve the problems in the <code>prepare-checkedCreate</code> pattern? The answer is yes.</p><p>For the first problem, an example analysis has been given earlier.</p><p>For the second problem, if the corresponding component is deleted during cluster update, the corresponding object will be deleted, so it can also be solved.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="how-to-obtain-the-old-version-of-the-cluster-object">How to obtain the old version of the <code>cluster</code> object?<a href="#how-to-obtain-the-old-version-of-the-cluster-object" class="hash-link" aria-label="Direct link to how-to-obtain-the-old-version-of-the-cluster-object" title="Direct link to how-to-obtain-the-old-version-of-the-cluster-object">​</a></h3><p>You may have a question. Where is the old version of the cluster object when generating the final plan?</p><p>We can see the old version of the cluster object and other related objects as a cluster snapshot. There are two ways to obtain the cluster snapshot:</p><ul><li>By-ControllerRevision: You can refer to the implementation of <a href="https://github.com/kubernetes/kubernetes/tree/release-1.25/pkg/controller/statefulset" target="_blank" rel="noopener noreferrer">StatefulSet</a> (see the <a href="https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/" target="_blank" rel="noopener noreferrer"><code>revisionHistoryLimit</code></a> documentation), record historical version clusters in the <a href="https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/controller-revision-v1/" target="_blank" rel="noopener noreferrer">ControllerRevision</a>, and generate an old version cluster snapshot through ControllerRevision during subsequent Reconcile.</li><li>By-Ownership: Objects belonging to the same cluster can be obtained through the OwnerReference relationship, and these objects can form an old version cluster snapshot.</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="comparison">Comparison<a href="#comparison" class="hash-link" aria-label="Direct link to Comparison" title="Direct link to Comparison">​</a></h4><p>The By-ControllerRevision method needs to introduce similar <code>revisionHistoryLimit</code> logic and rely on ControllerRevision objects. According to the <a href="https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/controller-revision-v1/" target="_blank" rel="noopener noreferrer">official documentation</a>, this has a certain risk:</p><blockquote><p>Note that, due to its use by both the DaemonSet and StatefulSet controllers for update and rollback, this object is beta. However, it may be subject to name and representation changes in future releases, and clients should not depend on its stability. It is primarily for internal use by controllers.</p></blockquote><p>The By-Ownership method needs to obtain all related objects. There are two ways to obtain them. One is to read the local cache, which may cause some problems due to the lag; the other is to directly obtain the &quot;latest&quot; objects through the API Server, but actually, due to the network, there is still a possibility of obtaining stale objects.</p><p>This refactoring of the lifecycle chooses the By-Ownership method because Ownership has been established in the current implementation and thus the workload is smaller.</p><p>Then there is one remaining question: is there a problem reading stale objects in the old version snapshot? Next, we will analyze this problem.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="stale-cache-problem-analysis">Stale Cache Problem Analysis<a href="#stale-cache-problem-analysis" class="hash-link" aria-label="Direct link to Stale Cache Problem Analysis" title="Direct link to Stale Cache Problem Analysis">​</a></h2><p>First of all, let&#x27;s draw a conclusion: there is no problem constructing the old version cluster snapshot based on the cache.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="problem-abstraction">Problem Abstraction<a href="#problem-abstraction" class="hash-link" aria-label="Direct link to Problem Abstraction" title="Direct link to Problem Abstraction">​</a></h3><p>There are two types of objects in the local cache: timely (latest) and stale (stale). The execution plan has three types of possible actions: <code>Create</code>, <code>Update</code>, and <code>Delete</code>.</p><p>Further, stale objects mean that the local cache is lagging behind the API Server versions, which means that a c/u/d (i.e. create/update/delete) arrangement can be used to express the increment of updates that have not been copied yet.</p><p>Formally, let&#x27;s define the &quot;+&quot; operation as a binary operation on the set {c, u, d}, which aims to transform two consecutive operations into one operation. It can be seen that <em>c+u=c</em>, <em>u+c=u</em>, <em>c+d=d</em>, <em>d+c=c</em>, <em>u+d=d</em>, and <em>d+u=u</em>. Therefore, a string composed of the arrangement of elements in the set {c, u, d} can be expressed by one element. Thus, the difference between stale objects and the API Server is just a c/u/d operation, which we represent as <code>c-lag</code>, <code>u-lag</code>, and <code>d-lag</code>.</p><p>So far, we classify Plan Action into three types and cache into four cases.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="problem-analysis">Problem Analysis<a href="#problem-analysis" class="hash-link" aria-label="Direct link to Problem Analysis" title="Direct link to Problem Analysis">​</a></h3><p>First, assuming that the latest snapshot does not change, that is, the cluster does not update.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="scenario-1-latest-cluster-snapshot-is-not-updated">Scenario 1. Latest Cluster Snapshot Is Not Updated<a href="#scenario-1-latest-cluster-snapshot-is-not-updated" class="hash-link" aria-label="Direct link to Scenario 1. Latest Cluster Snapshot Is Not Updated" title="Direct link to Scenario 1. Latest Cluster Snapshot Is Not Updated">​</a></h4><p>Next, we analyze whether there are problems after Plan Action combination execution with the four cache cases, as shown in the table below:
Cache\Plan Action</p><table><tr><td colspan="2"> Cache\Plan Action </td><td> Create </td><td> Update </td><td> Delete </td></tr><tr><td colspan="2"> Latest </td><td> ✅ </td><td> ✅ </td><td> ✅ </td></tr><tr><td rowspan="4"> Stale </td></tr><tr><td> c-lag </td><td> -- </td><td> ❌ </td><td> ❌ </td></tr><tr><td> u-lag </td><td> -- </td><td> ✅ </td><td> ✅ </td></tr><tr><td> d-lag </td><td> ❌ </td><td> -- </td><td> -- </td></tr></table><p>When the local cache is the latest, the snapshot obtained from the cache is the old version snapshot, so the Plan Action based on this snapshot can achieve the expected purpose.</p><p>When <code>c-lag</code> occurs, it means that the object exists on the API Server but not in the cache. At this time, the Plan should only be <em>Update</em> or <em>Delete</em>. However, because there is no cache, <em>Update</em> actually becomes <em>Create</em> to execute. When <em>Create</em> is executed, an object that already exists error (<code>metav1.StatusReasonAlreadyExists</code>) will be reported, and the result is inconsistent with expectations. <em>Delete</em> will not be generated, which means that the operation is lost, not as expected.
When <code>u-lag</code> occurs, it means that the object exists both in the API Server and in the cache, but the versions are different. At this time, the Plan should only consist of <code>Update</code> or <code>Delete</code> Actions, and the result should be consistent with expectations.</p><p>When <code>d-lag</code> occurs, it means that the object exists only in the cache and not in the API Server. At this time, the Plan should only consist of <code>Create</code> Actions, but because the object exists in the cache, <code>Create</code> becomes <code>Update</code> when executed. When <code>Update</code> is executed, an object not found error (<code>metav1.StatusReasonNotFound</code>) will be reported, and the result is inconsistent with expectations. When the object is not in the new snapshot, the Plan will incorrectly generate <code>Delete</code> Actions, which will also result in an object not found error.</p><p>At this point, constructing an old version snapshot based on the cache does indeed have problems. However, we still have a chance to remedy the situation. Let&#x27;s focus on one stale object in the entire old snapshot version for now.
<img loading="lazy" alt="Snapshot comparison" src="/assets/images/snapshot-comparison-5234d0e32a644a5e04d8fb003aa8ee48.png" width="4188" height="1232" class="img_ev3q"></p><p>The image above assumes that a cluster within KubeBlocks has been updated to version 3 (gen=3), and its generated secondary resources and their dependencies are shown on the left side of the image. It can be observed that there is a stale object on the left-hand side, which is the StatefulSet (gen=2).</p><p>The Reconcile process of <code>controller-runtime</code> is an <a href="https://en.wikipedia.org/wiki/Event-driven_architecture" target="_blank" rel="noopener noreferrer">EDA</a> model. When the update of this stale object reaches the cache, controller-runtime sends an event to the owner controller (that is, our cluster controller), and we have the opportunity to generate an execution Plan again. At this point, the object is in the latest (gen=3) state. According to the table above, the generated Plan execution is as expected. For other objects that are already in the latest state, updating them again will not have any other effects, as expected. Therefore, the problem is solved.</p><p>This process can be extended to multiple stale objects in the snapshot. Therefore, ultimately, by obtaining an old version snapshot from the local cache, we can ensure that the result meets expectations after several Reconciles.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="scenario-2-latest-cluster-snapshot-is-update">Scenario 2. Latest Cluster Snapshot Is Update<a href="#scenario-2-latest-cluster-snapshot-is-update" class="hash-link" aria-label="Direct link to Scenario 2. Latest Cluster Snapshot Is Update" title="Direct link to Scenario 2. Latest Cluster Snapshot Is Update">​</a></h4><p>If the latest cluster snapshot is updated, then it can be considered that all objects in the cache are stale, and the expected target becomes the updated snapshot. According to the previous analysis, even after several Reconciles, we can still ensure that the result meets expectations.</p><p>In summary, there is no problem with constructing an old version cluster snapshot through the cache, but we need to receive events for all objects in the snapshot (that is, when the controller is set up, it owns that GVK and sets the <code>SetControllerReference</code> parameters).</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2><p>This article discusses the problems with the current implementation of Kubernetes&#x27; Cluster Controller and introduces KubeBlocks, a new model that uses a Directed Acyclic Graph (DAG) to express a cluster. KubeBlocks uses Transformers to modify the DAG and a Plan to execute the final DAG. The article also addresses the issue of stale objects in the local cache and how KubeBlocks can handle this problem. The By-Ownership method is used to obtain the old version of the cluster object, and events are received for all objects in the snapshot to ensure that the result meets expectations after several Reconciles.</p></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_Wr5y"><div class="col"><b>Tags:</b><ul class="tags_jXut padding--none margin-left--sm"><li class="tag_QGVx"><a class="tag_zVej tagRegular_sFm0" href="/blog/tags/dag-model">DAG Model</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--next" href="/blog/third-blog-post"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">A Comparison and Analysis of ApeCloud MySQL High Availability Solutions</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#background" class="table-of-contents__link toc-highlight">Background</a></li><li><a href="#current-model---prepare-checkedcreate-pattern" class="table-of-contents__link toc-highlight">Current Model - <code>prepare-checkedCreate</code> pattern</a></li><li><a href="#the-kubeblocks-model" class="table-of-contents__link toc-highlight">The KubeBlocks Model</a><ul><li><a href="#why-do-we-use-dag" class="table-of-contents__link toc-highlight">Why do we use DAG?</a></li><li><a href="#the-plan" class="table-of-contents__link toc-highlight">The <em>Plan</em></a></li><li><a href="#how-to-obtain-the-old-version-of-the-cluster-object" class="table-of-contents__link toc-highlight">How to obtain the old version of the <code>cluster</code> object?</a></li></ul></li><li><a href="#stale-cache-problem-analysis" class="table-of-contents__link toc-highlight">Stale Cache Problem Analysis</a><ul><li><a href="#problem-abstraction" class="table-of-contents__link toc-highlight">Problem Abstraction</a></li><li><a href="#problem-analysis" class="table-of-contents__link toc-highlight">Problem Analysis</a></li></ul></li><li><a href="#conclusion" class="table-of-contents__link toc-highlight">Conclusion</a></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Products</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/">KubeBlocks</a></li></ul></div><div class="col footer__col"><div class="footer__title">Resources</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/docs/preview/user_docs/introduction">Docs</a></li><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a class="footer__link-item" href="/">Webinar</a></li></ul></div><div class="col footer__col"><div class="footer__title">Company</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/">About us</a></li><li class="footer__item"><a class="footer__link-item" href="/">News</a></li></ul></div><div class="col footer__col"><div class="footer__title">Contact us</div><ul class="footer__items clean-list"><li class="footer__item">
              <span class="contact-span">
                <a href="/" target="_blank" rel="noreferrer noopener" aria-label="Deploys by Netlify">
                  Email
                </a>
              </span>
            </li><li class="footer__item">
              <span class="contact-span">
                <a href="https://twitter.com" target="_blank" rel="noreferrer noopener" aria-label="Deploys by Netlify">
                  Twitter
                </a>
              </span>
            </li><li class="footer__item">
              <span class="contact-span">
                <a href="https://slack.com/" target="_blank" rel="noreferrer noopener" aria-label="Deploys by Netlify">
                  Slack
                </a>
              </span>
            </li><li class="footer__item">
              <span class="contact-span">
                <a href="https://www.linkedin.com/company/apecloud-technology-co-ltd/about/" target="_blank" rel="noreferrer noopener" aria-label="Deploys by Netlify">
                  Linkedin
                </a>
              </span>
            </li></ul></div></div><div class="footer__bottom text--center"><div class="margin-bottom--sm"><a class="footerLogoLink_BH7S" href="/"><img src="/img/logo.png" alt="Logo" class="themedImage_ToTc themedImage--light_HNdA footer__logo" width="72" height="18"><img src="/img/logo.png" alt="Logo" class="themedImage_ToTc themedImage--dark_i4oU footer__logo" width="72" height="18"></a></div><div class="footer__copyright">© 2023 ApeCloud Co., Ltd.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.f6a80365.js"></script>
<script src="/assets/js/main.5ffecbf3.js"></script>
</body>
</html>