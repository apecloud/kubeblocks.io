"use strict";(self.webpackChunkkubeblocks_io=self.webpackChunkkubeblocks_io||[]).push([[1477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"third-blog-post","metadata":{"permalink":"/blog/third-blog-post","editUrl":"https://github.com/apecloud/kubeblocks.io/tree/master/blog/2023-03-28-comparison-and-analysis-of-apecloud-mysql-high-availability-solutions.md","source":"@site/blog/2023-03-28-comparison-and-analysis-of-apecloud-mysql-high-availability-solutions.md","title":"A Comparison and Analysis of ApeCloud MySQL High Availability Solutions","description":"This is a comparison and analysis of current high availability solutions.","date":"2023-03-28T00:00:00.000Z","formattedDate":"March 28, 2023","tags":[{"label":"high availability","permalink":"/blog/tags/high-availability"}],"readingTime":12.53,"hasTruncateMarker":false,"authors":[{"name":"Dehao Wang","url":"https://github.com/IWonderWang","image_url":"https://avatars.githubusercontent.com/u/8622632?v=4","imageURL":"https://avatars.githubusercontent.com/u/8622632?v=4"}],"frontMatter":{"slug":"third-blog-post","title":"A Comparison and Analysis of ApeCloud MySQL High Availability Solutions","description":"This is a comparison and analysis of current high availability solutions.","authors":{"name":"Dehao Wang","url":"https://github.com/IWonderWang","image_url":"https://avatars.githubusercontent.com/u/8622632?v=4","imageURL":"https://avatars.githubusercontent.com/u/8622632?v=4"},"tags":["high availability"],"image":"https://github.com/apecloud/kubeblocks.io/blob/master/blog/assets/img/blog-banner.png?raw=true"},"nextItem":{"title":"Why isn\'t the open-source database operator popular?","permalink":"/blog/second-blog-post"}},"content":"## Overview of Database High Availability\\n\\nIn today\u2019s always-on digital world, any downtime can lead to lost revenue, decreased productivity, and unhappy customers. This is especially true for businesses that rely heavily on databases to store and manage data. Achieving high availability in a database system is crucial to ensure that a business\u2019s databases are always accessible and operational. In this article, we will provide an overview of database high availability and the four capabilities required to achieve it.\\n\\n### What is Database High Availability?\\n\\nDatabase high availability is the ability of a database system to remain operational and accessible even in the event of failures or outages. This is achieved by implementing various techniques like failover, replication, clustering, and load balancing. The goal of high availability is to ensure that the database can continue to function and provide access to data even if one or more components fail.\\n\\n### Four Capabilities for Achieving High Availability\\n\\nTo achieve high availability in a database system, the following four capabilities are required:\\n\\n#### Compute Redundancy\\n\\nThe computing layer redundancy is responsible for ensuring that when one instance fails, another can quickly take its place and continue providing read and write services. This can be achieved through creating multiple database instances to form a cluster. There are two ways to deploy redundancy at the computing layer:\\n\\n- **Active-Passive Mode**: Only one replica in the cluster provides read-write services, while the others can only offer read-only services.  Examples of this approach include MySQL primary-replica replication, SQL Server Failover Cluster Instance (FCI), and others. It\'s important to note that replicas can share a copy of the data (such as in SQL Server FCI), or they can store a separate copy of the data and synchronize it using a replication protocol (like in MySQL).\\n- **Active-Active Mode**: Multiple copies in the cluster provide read and write services simultaneously, such as Oracle RAC, MySQL Group Replication, and similar systems. Compared to the active-passive mode, this method has a faster switching speed and potentially higher resource utilization and load capacity. However, it requires addressing or bypassing write conflicts to ensure data consistency.\\n\\n#### Data Redundancy/Replication\\n\\nData redundancy or replication ensures that multiple copies of the service have their own copy of the data, enhancing database durability, and preventing data loss resulting from data corruption. Different levels of data redundancy can be achieved using the following approaches:\\n\\n- **Storage-Level Redundancy**: Multiple instances mount the same EBS, DRBD, establishing disk data mirroring between two servers, or rely on a clustered file system.\\n- **Database-Level Redundancy**: The replication module of the database system realizes data synchronization between replicas. The choice of synchronization method may affect the consistency, availability, and performance of the database system. Common synchronization methods include: \\n  - Asynchronous replication, such as MySQL Asynchronous Replication. Data is persisted in the primary copy first, and the data is asynchronously transmitted to other copies. This method has low write latency, and the failure of any copy does not affect availability. However, there is no guarantee that data will not be lost.\\n  - Synchronous replication, such as MySQL primary-replica synchronous replication and Percona XtraDB Cluster. Only after the data is persisted in the replicas can the user be notified of the successful writing. If any copy fails, there will be zero data loss, but it will also cause a large write delay. When any replica fails, the database system may be unable to provide service.\\n  - Replication based on consensus protocols, such as MySQL Group Replication and ApeCloud MySQL Paxos Group. Based on the consensus protocol represented by Paxos, data is synchronized among multiple replicas (generally no less than 3) to ensure consistency. It steps on the sweet spot between synchronous and asynchronous replication: a fixed number (more than half) of replicas need to be in sync to tell the user that the write was successful, but it doesn\'t matter which replicas. Guaranteed no data loss (RPO = 0) while tolerating certain node/network failures.\\n  - **External/Application-Level Redundancy**: Uses Kafka to pass messages to synchronize data or self-developed data synchronization programs, such as DTS, to achieve high availability on top of the database.\\n\\nThe implementation of storage-level redundancy and external redundancy relies on non-database systems, which is not the focus of this article.\\n\\n#### Failover Management\\n\\nFailover management monitors the failure of the primary of the database and upgrades another replica to a primary to provide external services.\\n\\n#### Service Endpoint Provisioning\\n\\nService endpoint provisioning ensures that the application system remains connected to the database even in the event of a failover, and can be achieved through elastic load balancing or adding a layer of Proxy.\\n\\n## Comparison between ApeCloud MySQL and other Main Stream MySQL High Availability Solutions\\n\\n### MySQL primary-replica/primary-primary replication\\n\\n![MySQL primary-replica/primary-primary replication](./assets/img/mysql-primary-replication.png)\\n\\nMySQL\'s official high-availability solution is now the most popular method for building a multi-copy database cluster and establishing a one-way (primary-replica) or two-way (primary-primary) replication channel. With primary-primary replication, two MySQL instances are mutually active acting as each others\' backup, and synchronize data. However, MySQL does not automatically handle write conflicts in this scenario. To avoid affecting database consistency, application developers usually have to find ways to bypass the write conflicts of multiple nodes, such as having each node write to different tables.\\n \\nMySQL primary-replica supports asynchronous and semi-synchronous replication of data. In semi-synchronous mode, when network problems or node downtime occur, affecting availability, it will be automatically downgraded to asynchronous replication. However, there is still a significant risk of data loss and RPO=0 cannot be guaranteed in asynchronous replication scenarios if the primary copy fails, and other copies may not have pulled all the data.\\n \\nThe principle of the semi-synchronous mode is that when the data is successfully persisted on the Primary and the specified number of Replicas during the commit process, the success message is returned to the client. Therefore, even if the Primary fails, all the data that has notified the client of successful commit must be found on a certain Replica. However, transaction commit in semi-synchronous mode involves multiple nodes and does not adopt a distributed coordination protocol such as a two-phase commit (2PC). If there is a failure in the commit process, there is still a risk of data inconsistency.\\n \\nFor example, suppose transaction T is being committed, and a failure occurs when the primary is in the Wait ACK phase. Assume that the replica has not received the binlog of T at this time, and when the replica is upgraded to primary, the modification of transaction T is not included. During the original Primary recovery process, the transaction T will be applied according to the persistent log. At this time, the data of the two copies is inconsistent.\\n\\n**Advantages**:\\n\\n1. The architecture is simple, widely validated, natively supported by MySQL, and has a good mass base.\\n2. Only two nodes are required at least, with fewer resource requirements. It can be extended with more nodes when needed.\\n3. Flexible configuration, supporting user trade-offs between consistency and performance/availability.\\n\\n**Disadvantages**:\\n\\n1. Only solve the problem of data transmission, and rely on third-party HA components to help fault detection and primary and replica switchover.\\n2. Cannot guarantee data consistency between primary and replica.\\n3. Asynchronous replication can lead to data loss.\\n4. No conflict detection for multi-primary writes.\\n\\n### MySQL Group Replication\\n\\n![MySQL group replication](./assets/img/mysql-group-replication.png)\\n\\nThe Paxos protocol has shined in the database field in recent years. Many database systems have introduced various variants of Paxos to ensure the consistency of data synchronization in multiple copies. The benefits of introducing the Paxos protocol are:\\n\\n1. On the premise of ensuring consistency, availability is maximized.\\n2. Decouple transaction commit logic and data synchronization logic.\\n\\nMySQL Group Replication (MGR) is a replication function based on the Paxos protocol officially launched by MySQL, which is embedded in MySQL as a plug-in. MGR supports single-node and multi-node writing, supports Leader election for single-node writing, and supports conflict detection and resolution for multi-node writing (multi-node writing mode has many restrictions, such as not supporting Serializable isolation level).\\n\\nHowever, there are certain problems in the design of MGR. The XCOM module (Paxos ) is embedded in MySQL as a plug-in. It is only responsible for deciding the commit order of transactions at the network level, not for persistence. The transaction commit is synchronized to other nodes through Paxos, and returns immediately after the log is persisted. That is to say, at the moment the transaction is committed, only the node (Primary) that accepts the request guarantees that the transaction is persistent. There are two problems with this design:\\n\\n1. In extreme cases, if the three machines are down at the same time, and the primary node data is damaged. After the other nodes are restarted, the transaction that has just been successfully submitted disappears. That is to say, in the case of the loss of minority nodes, MGR may also experience data loss.\\n2. Even if the Primary node is not damaged, in order to ensure that data is not lost, it is necessary to manually designate the original leader node as the \\"seed\\" node when restarting.\\n\\nIt can be seen that the current design of MGR does not fully utilize the power of Paxos, essentially because the Paxos protocol layer has no control over MySQL logs. You may ask: Why does the Replica node of MGR not wait for the log to be persisted before sending an ACK to the Primary node? Because of the current plug-in design of MGR, it is impossible to control the replica log apply. A Replica node persists the log successfully, but if the transaction fails to commit for some reason, the Replica will still apply the failed transaction.\\n\\n**Advantages**\uff1a\\n\\n1. In theory, the Paxos protocol strictly guarantees the consistency of data on multiple copies.\\n2. Support multi-node update to improve resource utilization.\\n3. Compared with primary-replica clusters, it has failover management and automatic scaling capabilities.\\n\\n**Disadvatages**:\\n\\n1. In order to support multi-node writing, there are more restrictions. See:\\n2. Only the InnoDB engine is supported.\\n3. At least three nodes are required, and the cost is relatively high.\\n4. Many operation and maintenance operations require manual intervention, such as restarting to select seed nodes.\\n5. In extreme cases, minority data damage may result in data loss in the cluster.\\n\\n### Percona XtraDB Cluster\\n\\n![Percona XtraDB Cluster](assets/img/percona-xtraDB-cluster.png)\\n\\nPercona XtraDB Cluster (PXC) is an open-source high-availability deployment solution developed by Percona, which relies on the open-source Galera library for data synchronization in the cluster. It is named after its enhanced version of the InnoDB storage engine - XtraDB. \\n\\np.s. MariaDB Galera Cluster, released by MariaDB, is also based on the Galera library and has similar capabilities to PXC.\\n \\nGalera is a relatively complex distributed protocol. Below are some of the features of PXC based on Galera:\\n\\n- Multiple primary synchronous replication is used, with instances in the cluster being equal and mutually primary-replica, and clients can connect to any instance.\\n- Transaction commit requires successful writing to all nodes. Optimistic strategies are used for transaction commit, where transactions are broadcast to all nodes after being locally submitted, and each node determines whether to roll back (locally first, then notifies other nodes to roll back) in the event of a conflict.\\n- When a node or network partition occurs, a majority of nodes that can still communicate with each other can automatically tolerate faults (exclude a minority of nodes that cannot write) and continue to provide writing. Therefore, it is recommended to deploy a single instance in the cluster.\\n \\n**Advantages**:\\n\\n1. Strong consistency of data across multiple nodes.\\n2. Supports multi-node updates, improving resource utilization.\\n3. Compared to primary-replica clusters, it has failover management and automatic scalability.\\n\\n**Disadvantages**:\\n\\n1. Limited support for multi-node writing. For details, please refer to [Percona XtraDB Cluster limitations - Percona XtraDB Cluster](https://docs.percona.com/percona-xtradb-cluster/8.0/limitation.html).\\n2. Only supports the InnoDB engine.\\n3. Requires at least three nodes, which is costly.\\n4. All nodes synchronize writing, and performance depends on the worst-performing node\'s resources, so reasonable resource planning and scheduling are required.\\n\\n### ApeCloud MySQL Paxos Group \\n\\n![ApeCloud MySQL Paxos Group](./assets/img/apecloud-mysql-paxos-group.png)\\n\\nApeCloud MySQL Paxos Group (AC-MPG) synchronizes data between replicas based on Raft, a variant of the Paxos protocol. Unlike MGR, AC-MPG has only one Leader to accept read and write requests, and other Follower nodes only respond to read requests. This design does not need to consider conflict detection. In terms of design, the Raft protocol layer is not embedded in MySQL as a plug-in, but is deeply integrated into the MySQL kernel, replacing the original replication module. The data synchronization between replicas is driven by the Raft Layer, and how to replicate and apply does not require external intervention. In order to realize higher efficiency, AC-MPG transforms Binlog as Raft log, so that Raft Layer can directly operate MySQL log.\\n\\nTherefore, AC-MPG does not have the same problems as MGR mentioned in the previous section, because:\\n\\n1. The condition for successful AC-MPG transaction commit is that the majority nodes persist the transaction log. The reason why this can be specified is that the Raft Layer is responsible for log transmission and apply. Even if the logs are successfully persisted on some nodes but the final transaction is not committed, the Raft Layer will not apply these logs according to the protocol. This is a capability that MGR does not have. In any case, if the data of the minority nodes is damaged, it will not cause the loss of cluster data.\\n2. Restarted nodes can automatically join the cluster without manual intervention.\\n\\nIn addition to Leader and Follower, AC-MPG also supports other roles: (1) Low-cost Logger nodes that do not store data and have voting rights but not the right to be elected. When necessary, AC-MPG can be equivalent to the cost of MySQL primary and backup. (2) A Learner node that does not have voting rights and only synchronizes data.\\n\\nIn addition to supporting the InnoDB engine, AC-MPG also supports the LSM-Tree engine X-Engine with a higher compression rate to achieve lower costs.\\n\\n**Advantages**:\\n\\n1. Multi-copy data consistency, RPO=0.\\n2. Supports low-cost Logger nodes and flexible Learner nodes.\\n3. Support low-cost X-Engine.\\n4. With failover management and automatic scaling capabilities, no manual intervention is required.\\n\\n**Disadvantage**:\\n\\n1. Only single-node write is supported.\\n\\n## Comparison\\n|                                    | Redundancy (Cost) | Failover Management| Consistency | RPO  | Write Performance | Multi-Write | Multi-Engine |\\n| :--   | :--               | :--                | :--         | :--  | :--               | :--         | :--          |\\n| MySQL Replication Asynchronization | Low  | N/A | Weak   | > 0 | Strong | N/A | Yes |\\n| MySQL Replication Synchronization  | Low  | N/A | Strong | 0   |        | Yes | Yes |\\n| MGR | High | Yes | Strong | \u2248 0 |     | Yes | N/A |\\n| PXC | High | Yes | Strong | 0   |     | Yes | N/A |\\n| ApeCloud MySQL Paxos Group | Configurable | Yes | Strong | 0   |        | N/A | Yes |\\\\"},{"id":"second-blog-post","metadata":{"permalink":"/blog/second-blog-post","editUrl":"https://github.com/apecloud/kubeblocks.io/tree/master/blog/2023-02-15-discuss-on-open-source-operator.md","source":"@site/blog/2023-02-15-discuss-on-open-source-operator.md","title":"Why isn\'t the open-source database operator popular?","description":"Kubernetes and open-source operators are becoming increasingly prevalent but why isn\'t the open-source database operator popular?","date":"2023-02-15T00:00:00.000Z","formattedDate":"February 15, 2023","tags":[{"label":"database operator","permalink":"/blog/tags/database-operator"},{"label":"open source","permalink":"/blog/tags/open-source"}],"readingTime":4.845,"hasTruncateMarker":false,"authors":[{"name":"Thomas","url":"https://github.com/realzyy","image_url":"https://avatars.githubusercontent.com/u/1814084?v=4","imageURL":"https://avatars.githubusercontent.com/u/1814084?v=4"}],"frontMatter":{"slug":"second-blog-post","title":"Why isn\'t the open-source database operator popular?","description":"Kubernetes and open-source operators are becoming increasingly prevalent but why isn\'t the open-source database operator popular?","authors":{"name":"Thomas","url":"https://github.com/realzyy","image_url":"https://avatars.githubusercontent.com/u/1814084?v=4","imageURL":"https://avatars.githubusercontent.com/u/1814084?v=4"},"tags":["database operator","open source"],"image":"https://github.com/apecloud/kubeblocks.io/blob/master/blog/assets/img/blog-banner.png?raw=true"},"prevItem":{"title":"A Comparison and Analysis of ApeCloud MySQL High Availability Solutions","permalink":"/blog/third-blog-post"}},"content":"It\'s unusual that even though Kubernetes and open-source operators are becoming increasingly prevalent, many Kubernetes developers still opt to use fully managed database services provided by cloud vendors to construct their applications. The database engines of AWS Aurora or Snowflake are robust, although they are not open source, so there\'s nothing inherently wrong with utilizing them in Kubernetes. However, what\'s most perplexing is the use of RDS (such as RDS for MySQL or RDS for PostgreSQL), whose database engine is essentially the same as the open-source community version; what is hindering developers from utilizing various open-source database operators to create a completely Kubernetes-native application architecture?\\n\\n## A comparison of fully managed databases and open-source database operator\\n\\nSurprisingly developers have not yet realized the cost discrepancy between fully-managed database services and equivalent computing resources, given that the cost of the former is 150% to 400% higher.\\nComparison of fully managed database cost and computing resource cost:\\n\\n| Public Cloud Provider | Deployment | Fully Managed Database Cost ($/hour) | Computing Resource Cost ($/hour) | Fully Managed Database Cost/Computing Resource Cost | Remarks | \\n| :--   | :--           | :--    | :--    | :--  | :--                                | \\n| AWS   | stand-alone   | 0.258  | 0.1344 | 192% | Oregon 4C/16GB <br />t4g.xlarge    |\\n| AWS   | one standby   | 0.517  | 0.2688 | 192% | Oregon 4C/16GB <br />t4g.xlarge    |\\n| AWS   | two standbys  | 1.044  | 0.5424 | 192% | Oregon 4C/16GB <br />m6gd.xlarge   |\\n| GCP   | stand-alone   | 0.2772 | 0.134  | 206% | Oregon 4C/16GB <br />e2-standard-4 |\\n| GCP   | HA            | 0.5544 | 0.268  | 206% | Oregon 4C/16GB <br />e2-standard-4 |\\n| Azure | stand-alone   | 0.39   | 0.198  | 197% | West US 4C/16GB <br />B4ms / D4as  |\\n| Azure | HA            | 1.47   | 0.396  | 371% | West US 4C/16GB <br />B4ms / D4as  |\\n\\nIn terms of capabilities, the open-source database operator offers a comprehensive deployment configuration. Although its functionality may not be completely covered by fully-managed database services, it cannot be argued that there is a significant difference. Let\'s take MySQL as an example.\\n\\n  * Both AWS RDS and the open-source database operator support stand-alone and multiple standby/read replica configurations, with the latter utilizing Group Replication and Proxy to achieve the same functionality.\\n  * AWS RDS has the ability to perform data backups through physical or logical methods, while the open-source database operator can achieve similar results using CSI or backup software.\\n  * In terms of monitoring, AWS RDS has a robust Performance Insight, but the open-source database operator usually relies on a more common combination of Prometheus and Grafana. This difference may not be noticeable to developers.\\n  * There is a significant difference in terms of compliance and user experience. AWS RDS has passed SOC, PCI, and other compliance projects, but running the open-source database operator on AWS EKS with caution can provide a similar level of data protection.\\n\\n## How far is the open-source operator from becoming popular?\\n\\nWhile the open-source database operator offers a significantly lower cost and appears to provide essential features, it is not as widely adopted as the fully managed database service from cloud vendors. Our discussions with many users revealed an intriguing phenomenon: among offline users who have limited access to cloud vendors, the open-source database operator is more popular and comparable in popularity to Kubernetes itself.\\nMany users noted that even though fully managed database services encounter various issues, they are typically resolved through the cloud provider\'s automation program or the operations team. On the other hand, while the open-source database operator is rapidly improving, it still lacks the capability to self-repair and there is no support from operations personnel. This partially explains why the open-source database operator is favored among offline users as having a dedicated operations team handling problems can be more comforting from an operational efficiency standpoint.\\n\\nThe Kubernetes community primarily categorizes user roles into two types: developers who deploy applications and operations staff who manage the cluster. Developers can independently expand the database by utilizing the open-source database operator. However, if there is a lack of resources, operations staff need to quickly add resources to the Kubernetes cluster. While they usually understand the resource needs of the application, they may not have a good understanding of the resources required by the database, which can lead to occasional problems like abnormal database synchronization that are hard to handle and cause stress. If developers also handle operations tasks (known as DevOps), the added workload and cognitive burden may discourage them from handling database operators and adopting fully managing the database service instead.\\n\\nAside from the reasons mentioned earlier, the inadequate integration of open-source database operators may also contribute to a less smooth user experience compared to fully managed database services. For instance, when creating a backup for MySQL, an open-source database operator may require additional steps such as allocating resources and configuring accounts for an object storage service in the Kubernetes cluster to store the backup file, whereas fully managed database services do not need these steps. Additionally, complex applications often involve multiple types of databases, such as MySQL and Redis. This may result in inconsistent user experiences with open-source database operators, whereas fully managed database services offer a unified design across the console, command line, and API, although the experience is often criticized.\\n\\nEven though there are challenges such as cognitive burden and limited integration, Kubernetes will continue to improve developer productivity and resource utilization, leading to a lasting influence on the world.\\nThese difficulties will eventually be overcome. If you face any issues with Kubernetes that cannot be resolved by open-source database operators or have any valuable experiences to share, please respond to [KubeBlocks](https://join.slack.com/t/kubeblocks/shared_invite/zt-1oz1hjyfk-UZwOJt8fge2TtWkTnuVfJg) or [DoK](https://dokcommunity.slack.com/join/shared_invite/zt-10v7uncvp-jNFwulsVWvUO0SKMDTjwAw#/shared-invite/email) to assist the Kubernetes community in advancing more rapidly."}]}')}}]);